{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Silvera Silvera is a tool for acceleration of development of microservice architectures. Silvera consists of two parts: a domain-specific language - SilveraDSL, and a Silvera compiler. SilveraDSL is a declarative language for modeling microservice architectures based on textX , and it is designed in a way that directly implements domain-related design patterns. SilveraDSL specifications are used by the compiler to produce executable program code. Silvera is fully implemented in Python. Feature highlights Designed patterns directly implemented in language Project modularization - imports Project evaluation based on metrics Automatic code generation Support for custom code generators via plugins Installation You can use pip to install Silvera: $ pip install silvera To verify that you have installed Silvera correctly run the following command: $ silvera You should get output like this: Usage: silvera [OPTIONS] COMMAND [ARGS]... Options: --debug Debug/trace output. --help Show this message and exit. Commands: check Checks if created model is valid. compile Compiles application code into to provided output... evaluate Evaluates the architecture for given project. init Creates initial Silvera project list-generators Lists all currently available code generators list-evaluators Lists all currently available architecture evaluators visualize Visualize the architecture for given project. Video tutorials Basics Messaging Microservice deployment options & custom code generator","title":"Home"},{"location":"#silvera","text":"Silvera is a tool for acceleration of development of microservice architectures. Silvera consists of two parts: a domain-specific language - SilveraDSL, and a Silvera compiler. SilveraDSL is a declarative language for modeling microservice architectures based on textX , and it is designed in a way that directly implements domain-related design patterns. SilveraDSL specifications are used by the compiler to produce executable program code. Silvera is fully implemented in Python.","title":"Silvera"},{"location":"#feature-highlights","text":"Designed patterns directly implemented in language Project modularization - imports Project evaluation based on metrics Automatic code generation Support for custom code generators via plugins","title":"Feature highlights"},{"location":"#installation","text":"You can use pip to install Silvera: $ pip install silvera To verify that you have installed Silvera correctly run the following command: $ silvera You should get output like this: Usage: silvera [OPTIONS] COMMAND [ARGS]... Options: --debug Debug/trace output. --help Show this message and exit. Commands: check Checks if created model is valid. compile Compiles application code into to provided output... evaluate Evaluates the architecture for given project. init Creates initial Silvera project list-generators Lists all currently available code generators list-evaluators Lists all currently available architecture evaluators visualize Visualize the architecture for given project.","title":"Installation"},{"location":"#video-tutorials","text":"","title":"Video tutorials"},{"location":"#basics","text":"","title":"Basics"},{"location":"#messaging","text":"","title":"Messaging"},{"location":"#microservice-deployment-options-custom-code-generator","text":"","title":"Microservice deployment options &amp; custom code generator"},{"location":"api_gateway/","text":"API gateway API gateway is the single entry point for all clients. Using API gateway comes with several benefits. Most notable are following: Client is unaware of the structure of the application, It's easier for client to determine location of service instances, Reduces the number of requests or roundtrips,... How to define an API gateway In the following example, we will define a service registry named EntryPoint : api-gateway EntryPoint { // gateway will be registered within ServiceRegistry instance service_registry = ServiceRegistry deployment { version=\"0.0.1\" port=9095 url=\"http://localhost\" host=container } communication_style=rpc gateway-for { User as /api/u Order as /api/o ... } } API gateway has following attributes: name (mandatory) - name of the API gateway. service_registry (optional) - reference to a service registry where the service will be registered, deployment (optional) - tells how gateway will be deployed (more info can be found here ), gateway-for (mandatory) - Maps service instance to URL. By using this URL, clients can reach corresponding the service.","title":"API gateway"},{"location":"api_gateway/#api-gateway","text":"API gateway is the single entry point for all clients. Using API gateway comes with several benefits. Most notable are following: Client is unaware of the structure of the application, It's easier for client to determine location of service instances, Reduces the number of requests or roundtrips,...","title":"API gateway"},{"location":"api_gateway/#how-to-define-an-api-gateway","text":"In the following example, we will define a service registry named EntryPoint : api-gateway EntryPoint { // gateway will be registered within ServiceRegistry instance service_registry = ServiceRegistry deployment { version=\"0.0.1\" port=9095 url=\"http://localhost\" host=container } communication_style=rpc gateway-for { User as /api/u Order as /api/o ... } } API gateway has following attributes: name (mandatory) - name of the API gateway. service_registry (optional) - reference to a service registry where the service will be registered, deployment (optional) - tells how gateway will be deployed (more info can be found here ), gateway-for (mandatory) - Maps service instance to URL. By using this URL, clients can reach corresponding the service.","title":"How to define an API gateway"},{"location":"commands/","text":"Silvera CLI commands Silvera has several CLI commands: check - used to check models for syntax and semantic validity, compile - used to compile model into to executable output, evaluate - used to evaluate the architecture for given project, init - used to create initial Silvera project, list-generators - used to lists all currently available code generators, list-evaluators - used to lists all currently available architecture evaluators, visualize - used to visualize the architecture for given project. To list all available commands just call the silvera : $ silvera Usage: silvera [OPTIONS] COMMAND [ARGS]... Options: --debug Debug/trace output. --help Show this message and exit. Commands: check Checks if created model is valid. compile Compiles application code into to provided output... evaluate Evaluates the architecture for given project. init Creates initial Silvera project list-generators Lists all currently available code generators visualize Visualize the architecture for given project.","title":"Silvera CLI commands"},{"location":"commands/#silvera-cli-commands","text":"Silvera has several CLI commands: check - used to check models for syntax and semantic validity, compile - used to compile model into to executable output, evaluate - used to evaluate the architecture for given project, init - used to create initial Silvera project, list-generators - used to lists all currently available code generators, list-evaluators - used to lists all currently available architecture evaluators, visualize - used to visualize the architecture for given project. To list all available commands just call the silvera : $ silvera Usage: silvera [OPTIONS] COMMAND [ARGS]... Options: --debug Debug/trace output. --help Show this message and exit. Commands: check Checks if created model is valid. compile Compiles application code into to provided output... evaluate Evaluates the architecture for given project. init Creates initial Silvera project list-generators Lists all currently available code generators visualize Visualize the architecture for given project.","title":"Silvera CLI commands"},{"location":"communication/","text":"Inter-service communication Service can use RPC (Remote procedure call) or Messaging communication style. RPC communication style is based on request-reply protocol. It is simple to use, but it creates coupling between client service and provider service. Messaging provides loose runtime coupling, but adds additional complexity to the system because you need to define message broker and message pool . Remote procedure call (RPC) When using RPC, in order for two services to be able to communicate, you must define a dependency between them. In the example that follows, we will define two dependencies for Order service. These are User service and Storage service. More precisely, Order service depends on User service methods userExist and userEmail , and Storage service method takeIngredient . dependency Order -> User { userExists[fail_fast] userEmail[fail_fast] } dependency Order -> Storage { takeIngredient[fail_fast] } Based on the dependency declaration, Silvera will generate a code that can be used to interact with the target service. What happens if User service or Storage service is unavailable when request takes place? Luckily, Silvera implements Circuit Breaker pattern, and how the situation is handled is defined by one of the following options: fail_fast - exception will be raised in the client if API call fails (default behavior), fail_silent - returns an empty response, fallback_method - defines a method that will be called in case the original method fails, fallback_static - returns default values, and fallback_cache - returns a cached version of response if present, otherwise returns empty response like fail_silent. Messaging Messaging communication style depends on two things: message broker, and message pool. !!! note In the current version, Silvera supports only Kafka as a message broker. Message pool Message pool is globally available object that contains all messages that are used withing the system. Message can contain parameters (command message) or not (event). Here's how to define a message pool with two messages: msg-pool { // define message group Commands group Commands [ msg CreateCommand[ str param1 str param2 ... ] ] // define message group Events group Events [ msg StorageItemTaken[] ] } Message broker Message broker is an entity whose responsibility is to deliver messages to a destination. Message broker contains channels where messages are stored. Services that add messages to channels are called publishers , while services that read messages from channels are called consumers . A service can be both publisher and consumer at the same time. Here's how to define a message broker: // message broker is named Broker msg-broker Broker { channel CMD_CREATE_COMMAND_CHANNEL(Commands.CreateCommand) channel EV_STORAE_ITEM_TAKEN_CHANNEL(Events.StorageItemTaken) As shown in the example above, channels in Silvera are typed . Which means, only messages of certain type can be added to the channel. How do I send messages? In order to send a message, you need to annotate an API method with @producer annotation. In following example, method takeFromStorage will send Events.StorageItemTaken message to the EV_STORAGE_ITEM_TAKEN_CHANNEL channel defined in broker named Broker . service Order [ ... api { ... @producer(Events.StorageItemTaken -> Broker.EV_STORAGE_ITEM_TAKEN_CHANNEL) bool takeFromStorage(i32 itemId) } ] !!! note Silvera will generate code that will publish the command to the messaging broker, but setting values to command's attributes need to be handled manually, otherwise empty message will be sent! How do I receive messages? In order to consume a message, you need to annotate an API method with @consumer annotation. In following example, internal method itemTakenListener will receive Events.StorageItemTaken message from the EV_STORAGE_ITEM_TAKEN_CHANNEL channel defined in broker named Broker . service StorageListener [ ... api { ... internal { @consumer(Events.StorageItemTaken <- Broker.EV_STORAGE_ITEM_TAKEN_CHANNEL) void itemTakenListener() } } ] In the generated code, itemTakenListener will have Events.StorageItemTaken object as a parameter.","title":"Inter-service communication"},{"location":"communication/#inter-service-communication","text":"Service can use RPC (Remote procedure call) or Messaging communication style. RPC communication style is based on request-reply protocol. It is simple to use, but it creates coupling between client service and provider service. Messaging provides loose runtime coupling, but adds additional complexity to the system because you need to define message broker and message pool .","title":"Inter-service communication"},{"location":"communication/#remote-procedure-call-rpc","text":"When using RPC, in order for two services to be able to communicate, you must define a dependency between them. In the example that follows, we will define two dependencies for Order service. These are User service and Storage service. More precisely, Order service depends on User service methods userExist and userEmail , and Storage service method takeIngredient . dependency Order -> User { userExists[fail_fast] userEmail[fail_fast] } dependency Order -> Storage { takeIngredient[fail_fast] } Based on the dependency declaration, Silvera will generate a code that can be used to interact with the target service. What happens if User service or Storage service is unavailable when request takes place? Luckily, Silvera implements Circuit Breaker pattern, and how the situation is handled is defined by one of the following options: fail_fast - exception will be raised in the client if API call fails (default behavior), fail_silent - returns an empty response, fallback_method - defines a method that will be called in case the original method fails, fallback_static - returns default values, and fallback_cache - returns a cached version of response if present, otherwise returns empty response like fail_silent.","title":"Remote procedure call (RPC)"},{"location":"communication/#messaging","text":"Messaging communication style depends on two things: message broker, and message pool. !!! note In the current version, Silvera supports only Kafka as a message broker.","title":"Messaging"},{"location":"communication/#message-pool","text":"Message pool is globally available object that contains all messages that are used withing the system. Message can contain parameters (command message) or not (event). Here's how to define a message pool with two messages: msg-pool { // define message group Commands group Commands [ msg CreateCommand[ str param1 str param2 ... ] ] // define message group Events group Events [ msg StorageItemTaken[] ] }","title":"Message pool"},{"location":"communication/#message-broker","text":"Message broker is an entity whose responsibility is to deliver messages to a destination. Message broker contains channels where messages are stored. Services that add messages to channels are called publishers , while services that read messages from channels are called consumers . A service can be both publisher and consumer at the same time. Here's how to define a message broker: // message broker is named Broker msg-broker Broker { channel CMD_CREATE_COMMAND_CHANNEL(Commands.CreateCommand) channel EV_STORAE_ITEM_TAKEN_CHANNEL(Events.StorageItemTaken) As shown in the example above, channels in Silvera are typed . Which means, only messages of certain type can be added to the channel.","title":"Message broker"},{"location":"communication/#how-do-i-send-messages","text":"In order to send a message, you need to annotate an API method with @producer annotation. In following example, method takeFromStorage will send Events.StorageItemTaken message to the EV_STORAGE_ITEM_TAKEN_CHANNEL channel defined in broker named Broker . service Order [ ... api { ... @producer(Events.StorageItemTaken -> Broker.EV_STORAGE_ITEM_TAKEN_CHANNEL) bool takeFromStorage(i32 itemId) } ] !!! note Silvera will generate code that will publish the command to the messaging broker, but setting values to command's attributes need to be handled manually, otherwise empty message will be sent!","title":"How do I send messages?"},{"location":"communication/#how-do-i-receive-messages","text":"In order to consume a message, you need to annotate an API method with @consumer annotation. In following example, internal method itemTakenListener will receive Events.StorageItemTaken message from the EV_STORAGE_ITEM_TAKEN_CHANNEL channel defined in broker named Broker . service StorageListener [ ... api { ... internal { @consumer(Events.StorageItemTaken <- Broker.EV_STORAGE_ITEM_TAKEN_CHANNEL) void itemTakenListener() } } ] In the generated code, itemTakenListener will have Events.StorageItemTaken object as a parameter.","title":"How do I receive messages?"},{"location":"compilation/","text":"From model to runnable !!! note Java 1.8 is needed to run generated code! Compile and run the project First, you need to compile the model. For compilation, use the following command: $ silvera compile <project_dir> -o <output_dir> If model is compiled successfully, before you run the applications, first you need to run MongoDB instance: $ sudo systemctl start mongo.service If your application is using messaging communication style, you need to run Zookeper and Kafka before starting an applications. To run Zookeper run the following command: $ cd <kafka_project> $ bin/zookeeper-server-start.sh config/zookeeper.properties To run Kafka run following command: $ cd <kafka_project> $ bin/kafka-server-start.sh config/server.properties After that, go to the output directory and run run.sh script: $ cd <output_dir> $ sh run.sh Introduce manual changes to the generated code The functionality of custom functions needs to be added manually. During the compilation, Silvera produces a Java project with the following structure: <MicroserviceName> | src | main \u2514\u2500\u2500\u2500java \u2514\u2500\u2500\u2500 com.silvera.<MicroserviceName> \u2514\u2500\u2500\u2500controller \u2514\u2500\u2500\u2500 domain.model \u2514\u2500\u2500\u2500 service \u2514\u2500\u2500\u2500 base \u2514\u2500\u2500\u2500 impl \u2514\u2500\u2500\u2500App.java \u2514\u2500\u2500\u2500 resources |test | pom.xml | run.cmd | run.sh Package service.impl contains the implementation of service functions. Here, you can provide the custom functions the necessary functionality. For example, for the User microservice (check section Service declaration ), the generated UserService.java looks like this: // UserService.java ... @Service public class UserService implements IUserService { @Autowired UserRepository userRepository; public UserService(){ super(); } // Auto-generated CRUD methods @Override public User createUser(User user){ userRepository.save(user); Optional<User> opt = userRepository.findById(user.getId()); return opt.orElse(null); } @Override public User updateUser(java.lang.String id, User userUpdate){ User entity = this.readUser(id); userRepository.save(userUpdate); return userUpdate; } @Override public User readUser(java.lang.String id){ Optional<User> opt = userRepository.findById(id); return opt.orElseThrow(IllegalArgumentException::new); } @Override public void deleteUser(java.lang.String id){ User entity = readUser(id); userRepository.delete(entity); } @Override public java.util.List<User> listUsers() { /* TODO: Implement this function!!! */ throw new java.lang.UnsupportedOperationException(\"Not implemented yet.\"); } @Override public java.lang.Boolean userExist(java.lang.String username) { /* TODO: Implement this function!!! */ throw new java.lang.UnsupportedOperationException(\"Not implemented yet.\"); } @Override public java.lang.String userEmail(java.lang.String username) { /* TODO: Implement this function!!! */ throw new java.lang.UnsupportedOperationException(\"Not implemented yet.\"); } } As seen above, the CRUD methods are provided with the default functionality, but custom functions listUsers , userExists , and userEmail must be implemented manualy. The functionality is added by simply changing the implementation of these functions. !!! note This file will preserve its changes between successive compilations. Meaning, if the base service is changed in the meantime, this file needs to be updated manually.","title":"Compilation"},{"location":"compilation/#from-model-to-runnable","text":"!!! note Java 1.8 is needed to run generated code!","title":"From model to runnable"},{"location":"compilation/#compile-and-run-the-project","text":"First, you need to compile the model. For compilation, use the following command: $ silvera compile <project_dir> -o <output_dir> If model is compiled successfully, before you run the applications, first you need to run MongoDB instance: $ sudo systemctl start mongo.service If your application is using messaging communication style, you need to run Zookeper and Kafka before starting an applications. To run Zookeper run the following command: $ cd <kafka_project> $ bin/zookeeper-server-start.sh config/zookeeper.properties To run Kafka run following command: $ cd <kafka_project> $ bin/kafka-server-start.sh config/server.properties After that, go to the output directory and run run.sh script: $ cd <output_dir> $ sh run.sh","title":"Compile and run the project"},{"location":"compilation/#introduce-manual-changes-to-the-generated-code","text":"The functionality of custom functions needs to be added manually. During the compilation, Silvera produces a Java project with the following structure: <MicroserviceName> | src | main \u2514\u2500\u2500\u2500java \u2514\u2500\u2500\u2500 com.silvera.<MicroserviceName> \u2514\u2500\u2500\u2500controller \u2514\u2500\u2500\u2500 domain.model \u2514\u2500\u2500\u2500 service \u2514\u2500\u2500\u2500 base \u2514\u2500\u2500\u2500 impl \u2514\u2500\u2500\u2500App.java \u2514\u2500\u2500\u2500 resources |test | pom.xml | run.cmd | run.sh Package service.impl contains the implementation of service functions. Here, you can provide the custom functions the necessary functionality. For example, for the User microservice (check section Service declaration ), the generated UserService.java looks like this: // UserService.java ... @Service public class UserService implements IUserService { @Autowired UserRepository userRepository; public UserService(){ super(); } // Auto-generated CRUD methods @Override public User createUser(User user){ userRepository.save(user); Optional<User> opt = userRepository.findById(user.getId()); return opt.orElse(null); } @Override public User updateUser(java.lang.String id, User userUpdate){ User entity = this.readUser(id); userRepository.save(userUpdate); return userUpdate; } @Override public User readUser(java.lang.String id){ Optional<User> opt = userRepository.findById(id); return opt.orElseThrow(IllegalArgumentException::new); } @Override public void deleteUser(java.lang.String id){ User entity = readUser(id); userRepository.delete(entity); } @Override public java.util.List<User> listUsers() { /* TODO: Implement this function!!! */ throw new java.lang.UnsupportedOperationException(\"Not implemented yet.\"); } @Override public java.lang.Boolean userExist(java.lang.String username) { /* TODO: Implement this function!!! */ throw new java.lang.UnsupportedOperationException(\"Not implemented yet.\"); } @Override public java.lang.String userEmail(java.lang.String username) { /* TODO: Implement this function!!! */ throw new java.lang.UnsupportedOperationException(\"Not implemented yet.\"); } } As seen above, the CRUD methods are provided with the default functionality, but custom functions listUsers , userExists , and userEmail must be implemented manualy. The functionality is added by simply changing the implementation of these functions. !!! note This file will preserve its changes between successive compilations. Meaning, if the base service is changed in the meantime, this file needs to be updated manually.","title":"Introduce manual changes to the generated code"},{"location":"configuration_server/","text":"Configuration server Enables centralized configuration. Here's how to define one: config-server ConfigServer { // path to the properties folder search_path=\"file://${user.home}/Projects/MicroServiceProps/centralProperties/\" deployment { version=\"0.0.1\" port=9090 } }","title":"Configuration server"},{"location":"configuration_server/#configuration-server","text":"Enables centralized configuration. Here's how to define one: config-server ConfigServer { // path to the properties folder search_path=\"file://${user.home}/Projects/MicroServiceProps/centralProperties/\" deployment { version=\"0.0.1\" port=9090 } }","title":"Configuration server"},{"location":"custom_generator/","text":"Custom generator Silvera allows users to register new code generators as plugins. Silvera uses the pkg_resources module from setuptools and its concept of extension point to declaratively specify the registration of the new code generator. Extensions are defined within the project's setup.py module. All Python projects installed in the environment that declare the extension point will be discoverable dynamically. Registration of a new code generator is performed in two steps (as shown below). You can also follow the video tutorial: Step 1 Create an instance of GeneratorDesc class. An instance of GeneratorDesc class contains information about the code generator's target language, description, and the reference towards the function that should be called to perform code generation. This function has three parameters: Decl object, a path to the directory where code will be generated, and a flag that shows whether the code generator is run in debug mode. from silvera.generator.gen_reg import GeneratorDesc def generate(decl, output_dir, debug): \"\"\"Entry point function for code generator. Args: decl(Decl): can be declaration of service registry or config server. output_dir(str): output directory. debug(bool): True if debug mode activated. False otherwise. \"\"\" ... python = GeneratorDesc( language_name=\"python\", language_ver=\"3.7.4\", description=\"Python 3.7.4 code generator\", gen_func=generate ) Step 2 Now, we need to make the code generator discoverable by Silvera. To do this, we must register the GeneratorDesc object in the setup.py entry point named silvera_generators : # setup.py from setuptools import setup setup( ... entry_points={ 'silvera_generators': [ 'python = pygen.generator:python' ] } )","title":"Registering custom generator"},{"location":"custom_generator/#custom-generator","text":"Silvera allows users to register new code generators as plugins. Silvera uses the pkg_resources module from setuptools and its concept of extension point to declaratively specify the registration of the new code generator. Extensions are defined within the project's setup.py module. All Python projects installed in the environment that declare the extension point will be discoverable dynamically. Registration of a new code generator is performed in two steps (as shown below). You can also follow the video tutorial:","title":"Custom generator"},{"location":"custom_generator/#step-1","text":"Create an instance of GeneratorDesc class. An instance of GeneratorDesc class contains information about the code generator's target language, description, and the reference towards the function that should be called to perform code generation. This function has three parameters: Decl object, a path to the directory where code will be generated, and a flag that shows whether the code generator is run in debug mode. from silvera.generator.gen_reg import GeneratorDesc def generate(decl, output_dir, debug): \"\"\"Entry point function for code generator. Args: decl(Decl): can be declaration of service registry or config server. output_dir(str): output directory. debug(bool): True if debug mode activated. False otherwise. \"\"\" ... python = GeneratorDesc( language_name=\"python\", language_ver=\"3.7.4\", description=\"Python 3.7.4 code generator\", gen_func=generate )","title":"Step 1"},{"location":"custom_generator/#step-2","text":"Now, we need to make the code generator discoverable by Silvera. To do this, we must register the GeneratorDesc object in the setup.py entry point named silvera_generators : # setup.py from setuptools import setup setup( ... entry_points={ 'silvera_generators': [ 'python = pygen.generator:python' ] } )","title":"Step 2"},{"location":"deployment/","text":"Deployment Deployment is used to describe how Deployable ( service , service registry , API gateway or configuration server ) object will be deployed. Deployment contains following attributes: version (optional) - defines a version of Deployable object, url (optional) - defines an URL where can be reached, port (optional) - defines a port where can be reached, lang (optional) - defines a programming language to be used as a target language, host (optional) - defines a host of the generated code (PC or container), replicas (optional) - defines a number of service replicas which will be started, restart_policy (optional) - defines a restart policy for a service. !!! note Current version of Silvera has no support for replicas and restart_policy. Model will be compiled, but these attributes will be ignored. Following example shows how deployable can be defined: deployment { version=\"0.0.1\" port=9091 url=\"http://localhost\" host=container } If lang is omitted, Silvera will generate Java source code.","title":"Deployment options"},{"location":"deployment/#deployment","text":"Deployment is used to describe how Deployable ( service , service registry , API gateway or configuration server ) object will be deployed. Deployment contains following attributes: version (optional) - defines a version of Deployable object, url (optional) - defines an URL where can be reached, port (optional) - defines a port where can be reached, lang (optional) - defines a programming language to be used as a target language, host (optional) - defines a host of the generated code (PC or container), replicas (optional) - defines a number of service replicas which will be started, restart_policy (optional) - defines a restart policy for a service. !!! note Current version of Silvera has no support for replicas and restart_policy. Model will be compiled, but these attributes will be ignored. Following example shows how deployable can be defined: deployment { version=\"0.0.1\" port=9091 url=\"http://localhost\" host=container } If lang is omitted, Silvera will generate Java source code.","title":"Deployment"},{"location":"evaluation/","text":"Evaluation Silvera uses predefined metrics to evaluate the modeled application: Weighted Service Interface Count (WSIC) - This metric counts the number of exposed interface operations of a service. Lower values for WSIC are more favorable for the maintainability of a service. Number of Versions per Service (NVS) - The number of versions that are used concurrently in system Y for service S. Services Interdependence in the System (SIY) - Pairs \u27e8S 1 , S 2 \u27e9 where service S1 calls S2 while service S2 also calls S1 at some point. Absolute Importance of the Service (AIS) - AIS(S) for a service S is the number of consumers that depend on S, i.e. the number of clients that invoke at least one operation of S Absolute Dependence of the Service (ADS) - ADS(S) is the number of other services that S depends on, i.e. the number of services from which S invokes at least one operation. Absolute Criticality of the Service (ACS) - ACS(S) = AIS(S) \u00d7 ADS(S) To perform evaluation, run following command $ silvera evaluate <project_dir>","title":"Model evaluation"},{"location":"evaluation/#evaluation","text":"Silvera uses predefined metrics to evaluate the modeled application: Weighted Service Interface Count (WSIC) - This metric counts the number of exposed interface operations of a service. Lower values for WSIC are more favorable for the maintainability of a service. Number of Versions per Service (NVS) - The number of versions that are used concurrently in system Y for service S. Services Interdependence in the System (SIY) - Pairs \u27e8S 1 , S 2 \u27e9 where service S1 calls S2 while service S2 also calls S1 at some point. Absolute Importance of the Service (AIS) - AIS(S) for a service S is the number of consumers that depend on S, i.e. the number of clients that invoke at least one operation of S Absolute Dependence of the Service (ADS) - ADS(S) is the number of other services that S depends on, i.e. the number of services from which S invokes at least one operation. Absolute Criticality of the Service (ACS) - ACS(S) = AIS(S) \u00d7 ADS(S) To perform evaluation, run following command $ silvera evaluate <project_dir>","title":"Evaluation"},{"location":"service/","text":"Service Service is a mechanism to enable access to one or more capabilities, where the access is provided using a prescribed interface and is exercised consistent with constraints and policies as specified by the service description [^1]. How to define a service In the following example, we will define a service named User , which will register itself within a service registry called ServiceRegistry . service User { service_registry=ServiceRegistry communication_style=rpc api{ @crud typedef User [ @id str username @required str password @required str email ] @rest(method=GET) list<User> listUsers() @rest(method=GET) bool userExists(str username) @rest(method=GET) str userEmail(str username) } } Attributes: name (mandatory) - name of the service. service_registry (optional) - reference to a service registry where the service will be registered, communication_style - tells which communication style will service use. This attribute can have either rpc or messaging as a value, deployment (optional) - tells how service will be deployed (more info can be found here ), api (mandatory) - API of the service. Here you define all domain objects (via typedef ) and functions accessible from the outside. Communication style Communication style of a service is defined by communication_style attribute. Service can use RPC (Remote procedure call) or Messaging communication style. To see how services can communicate, click here . Attribute communication style is set like this: service User { ... communication_style=rpc ... } or service User { ... communication_style=messaging ... } API definition Defining domain-objects To define a domain object, use typedef construct. For example: typedef Point [ int x int y ] Each typedef has a name and one-or-more fields . Field has following attributes: data type (mandatory) - field's data type (list of available data types is here ), name (mandatory) - field's name, classifiers (optional): id - marks field as typedef s ID. Use @id annotation to set field as ID. required - marks field as required. Use @required annotation to set field as required. unique - value of the field must be unique in the database. Use @unique annotation to set field as unique. ordered - typedef will be sorted by this field when retrieving from the database. Use @ordered annotation to set field as ordered. !!! note Classifiers unique and ordered are only partially supported for now! Following example demonstrates how to define fields with aforementioned attributes: typedef User [ @id str username @required str password @required @unique str email ] or in different formatting: typedef User [ @id str username @required str password @required @unique str email ] Domain objects are accessible only within the service itself. To manipulate with domain objects you need methods. CRUD methods for a domain object can be generated automatically by applying CRUD annotations: @crud - generates ALL CRUD methods for a typedef, @create - generates only CREATE method, @read - generates only READ method for a typedef, @update - generates only UPDATE method for a typedef, and @delete - generates only DELETE method for a typedef. Here's how CRUD annotations can be used: // generate all CRUD methods @crud typedef Point [ int x int y ] // or // generate only create method @create typedef Point [ int x int y ] // or // generate only read method @read typedef Point [ int x int y ] // combining multiple annotations is also possible... // like this: // generate create and read methods @create @read typedef Point [ int x int y ] Defining API methods Methods are defined similarly to Java or C#: bool userExists(str username) Each method has: return type (mandatory), name (mandatory), parameters (optional) Each method can be annotated with @rest annotation. For example // generates following REST mapping: \"/userexists/{username}\" @rest(method=GET) bool userExists(str username) // you can also provide a custom mapping @rest(method=GET, mapping=\"/exists/{username}\") bool userExists(str username) All HTTP methods are supported by @rest annotation. If @rest annotation is omitted, Silvera will try to figure out the which HTTP method to use, or it will throw exception. !!! note In the current version of Silvera, calculating proper @rest annotation is little buggy, so please set annotations manually. Besides @rest , method can also be annotated with messaging annotations: @producer - annotates method as a message producer, or @consumer - annotates methods as a message consumer. Methods can be either public or internal . Consumer methods are usually only used as internal. Following example shows how to define both set of methods: service EmailNotifier { ... api{ ... // // this will be public method: // @rest(method=GET) list<Notification> listNotifications() // Internal methods are defined in within `internal` scope: internal { // Consumes 'OrderMsgGroup.OrderCreated' message from // 'EV_ORDER_CREATED_CHANNEL' channel defined in 'Broker' @consumer(OrderMsgGroup.OrderCreated <- Broker.EV_ORDER_CREATED_CHANNEL) void orderCreated() } } } Consumer methods will be generated with corresponding message object as a parameter. For example, in Java, method orderCreated will look like this: private orderCreated(com.silvera.EmailNotifier.messages.ordermsggroup.OrderCreated message){ ... } [^1]: OASIS Reference Model for Service Oriented Architecture 1.0","title":"Service declaration"},{"location":"service/#service","text":"Service is a mechanism to enable access to one or more capabilities, where the access is provided using a prescribed interface and is exercised consistent with constraints and policies as specified by the service description [^1].","title":"Service"},{"location":"service/#how-to-define-a-service","text":"In the following example, we will define a service named User , which will register itself within a service registry called ServiceRegistry . service User { service_registry=ServiceRegistry communication_style=rpc api{ @crud typedef User [ @id str username @required str password @required str email ] @rest(method=GET) list<User> listUsers() @rest(method=GET) bool userExists(str username) @rest(method=GET) str userEmail(str username) } } Attributes: name (mandatory) - name of the service. service_registry (optional) - reference to a service registry where the service will be registered, communication_style - tells which communication style will service use. This attribute can have either rpc or messaging as a value, deployment (optional) - tells how service will be deployed (more info can be found here ), api (mandatory) - API of the service. Here you define all domain objects (via typedef ) and functions accessible from the outside.","title":"How to define a service"},{"location":"service/#communication-style","text":"Communication style of a service is defined by communication_style attribute. Service can use RPC (Remote procedure call) or Messaging communication style. To see how services can communicate, click here . Attribute communication style is set like this: service User { ... communication_style=rpc ... } or service User { ... communication_style=messaging ... }","title":"Communication style"},{"location":"service/#api-definition","text":"","title":"API definition"},{"location":"service/#defining-domain-objects","text":"To define a domain object, use typedef construct. For example: typedef Point [ int x int y ] Each typedef has a name and one-or-more fields . Field has following attributes: data type (mandatory) - field's data type (list of available data types is here ), name (mandatory) - field's name, classifiers (optional): id - marks field as typedef s ID. Use @id annotation to set field as ID. required - marks field as required. Use @required annotation to set field as required. unique - value of the field must be unique in the database. Use @unique annotation to set field as unique. ordered - typedef will be sorted by this field when retrieving from the database. Use @ordered annotation to set field as ordered. !!! note Classifiers unique and ordered are only partially supported for now! Following example demonstrates how to define fields with aforementioned attributes: typedef User [ @id str username @required str password @required @unique str email ] or in different formatting: typedef User [ @id str username @required str password @required @unique str email ] Domain objects are accessible only within the service itself. To manipulate with domain objects you need methods. CRUD methods for a domain object can be generated automatically by applying CRUD annotations: @crud - generates ALL CRUD methods for a typedef, @create - generates only CREATE method, @read - generates only READ method for a typedef, @update - generates only UPDATE method for a typedef, and @delete - generates only DELETE method for a typedef. Here's how CRUD annotations can be used: // generate all CRUD methods @crud typedef Point [ int x int y ] // or // generate only create method @create typedef Point [ int x int y ] // or // generate only read method @read typedef Point [ int x int y ] // combining multiple annotations is also possible... // like this: // generate create and read methods @create @read typedef Point [ int x int y ]","title":"Defining domain-objects"},{"location":"service/#defining-api-methods","text":"Methods are defined similarly to Java or C#: bool userExists(str username) Each method has: return type (mandatory), name (mandatory), parameters (optional) Each method can be annotated with @rest annotation. For example // generates following REST mapping: \"/userexists/{username}\" @rest(method=GET) bool userExists(str username) // you can also provide a custom mapping @rest(method=GET, mapping=\"/exists/{username}\") bool userExists(str username) All HTTP methods are supported by @rest annotation. If @rest annotation is omitted, Silvera will try to figure out the which HTTP method to use, or it will throw exception. !!! note In the current version of Silvera, calculating proper @rest annotation is little buggy, so please set annotations manually. Besides @rest , method can also be annotated with messaging annotations: @producer - annotates method as a message producer, or @consumer - annotates methods as a message consumer. Methods can be either public or internal . Consumer methods are usually only used as internal. Following example shows how to define both set of methods: service EmailNotifier { ... api{ ... // // this will be public method: // @rest(method=GET) list<Notification> listNotifications() // Internal methods are defined in within `internal` scope: internal { // Consumes 'OrderMsgGroup.OrderCreated' message from // 'EV_ORDER_CREATED_CHANNEL' channel defined in 'Broker' @consumer(OrderMsgGroup.OrderCreated <- Broker.EV_ORDER_CREATED_CHANNEL) void orderCreated() } } } Consumer methods will be generated with corresponding message object as a parameter. For example, in Java, method orderCreated will look like this: private orderCreated(com.silvera.EmailNotifier.messages.ordermsggroup.OrderCreated message){ ... } [^1]: OASIS Reference Model for Service Oriented Architecture 1.0","title":"Defining API methods"},{"location":"service_registry/","text":"Service Registry Service registry is database of services. It contains information about all service instances and their locations. If used, client service can use service registry to determine the location of a service instance to which it wants to send requests. How to define a service registry In the following example, we will define a service registry named ServiceRegistry : service_registry ServiceRegistry { tool=eureka client_mode=False deployment { version=\"0.0.1\" port=9091 url=\"http://localhost\" host=container } } As seen above, service registry has following attributes: name (mandatory) - name of the service registry. tool (mandatory) - defines which tool will be used as a service registry. Currently, Silvera supports only Eureka. client_mode (mandatory) - defines whether service registry can be registered within another service registry or not. deployment (mandatory) - defines how registry will be deployed. Attributes of deployment are defined here .","title":"Service registry declaration"},{"location":"service_registry/#service-registry","text":"Service registry is database of services. It contains information about all service instances and their locations. If used, client service can use service registry to determine the location of a service instance to which it wants to send requests.","title":"Service Registry"},{"location":"service_registry/#how-to-define-a-service-registry","text":"In the following example, we will define a service registry named ServiceRegistry : service_registry ServiceRegistry { tool=eureka client_mode=False deployment { version=\"0.0.1\" port=9091 url=\"http://localhost\" host=container } } As seen above, service registry has following attributes: name (mandatory) - name of the service registry. tool (mandatory) - defines which tool will be used as a service registry. Currently, Silvera supports only Eureka. client_mode (mandatory) - defines whether service registry can be registered within another service registry or not. deployment (mandatory) - defines how registry will be deployed. Attributes of deployment are defined here .","title":"How to define a service registry"},{"location":"types/","text":"Data types Built-in types Here's the list on build-in types: void date int float double str list set dict Custom types Defined as typedef s. For more info check here","title":"Data types"},{"location":"types/#data-types","text":"","title":"Data types"},{"location":"types/#built-in-types","text":"Here's the list on build-in types: void date int float double str list set dict","title":"Built-in types"},{"location":"types/#custom-types","text":"Defined as typedef s. For more info check here","title":"Custom types"}]}