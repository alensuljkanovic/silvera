Module:
    decls*=Declaration
;

Declaration:
    ConfigServerDecl | ServiceRegistryDecl | ServiceDecl | APIGateway | Connection
;

ConfigServerDecl:
    'config-server' name=ID '{'
        'version' '=' version=STRING
        'port' '=' port=INT
        'search_path' '=' search_path=STRING
    '}'
;

ServiceRegistryDecl:
    'service-registry' name=ID '{'
        'version' '=' version=STRING
        'tool' '=' tool=ServiceRegistryTool
        'port' '=' port=INT
        'uri' '=' uri=STRING
        'client_mode' '=' client_mode=BOOL
    '}'
;

ServiceRegistryTool:
    "eureka" | "zookeeper" | "consul"
;

APIGateway:
    'api-gateway' name=ID '{'
        'version' '=' version=STRING
        'port' '=' port=INT
        ('config_server' '=' config_server=[ConfigServerDecl])?
        ('service_registry' '=' service_registry=[ServiceRegistryDecl])?
        'lang' '=' lang=STRING
        'deployment' '{'
            'packaging' '=' packaging=STRING
            'host' '=' host=HostChoice
            'n' '=' num_of_instances=INT
        '}'
        'communication_style' '=' comm_style=CommunicationStyle

        'gateway-for' '{'
            gateway_for+=GatewayFor
        '}'
    '}'
;

GatewayFor:
    service=[ServiceDecl] 'as' url=STRING
;

ServiceDecl:
    'service' name=ID '{'
        'version' '=' version=STRING
        'port' '=' port=INT
        ('config_server' '=' config_server=[ConfigServerDecl])?
        ('service_registry' '=' service_registry=[ServiceRegistryDecl])?
        'lang' '=' lang=STRING
        'deployment' '{'
            'packaging' '=' packaging=STRING
            'host' '=' host=HostChoice
            'n' '=' num_of_instances=INT
        '}'
        'communication_style' '=' comm_style=CommunicationStyle
        (requires=ServiceRequirement)?

        api=APIDecl
    '}'
;

ServiceRequirement:
    'requires' '{'
        requirements+=RequirementEntry

    '}'
;

RequirementEntry:
    service=ID ('[' version=STRING ']')? (circuit_break?='circuit-break')?
;


APIDecl:
    'api' '{'
        typedefs*=TypeDef
        functions*=Function
    '}'
;

Connection:
    'connection' start=[Declaration] '->' end=[Declaration] '{'
        circuit_break_defs*=CBPerMethod
    '}'
;

CBPerMethod:
    method_name=ID '[' failure_pattern=CBFailurePattern (fallback_method=ID)? ']'
;

CBFailurePattern:
    'fail_fast' | 'fail_silent' | 'fallback_static' | 'fallback_stubbed' | 'fallback_cache' | 'fallback_method'
;


TypeDef:
    'typedef' name=ID (':' inherits+=[TypeDef][','])? '['
        fields+=TypeField
    ']'
;

TypeField:
    (id=INT ':')? type=DataType name=ID
;

HostChoice:
    "PC" | "VM" | "container" | "serverless"
;

CommunicationStyle:
    "REST" | "gRPC" | "thrift" | "kafka" | "RabbitMQ" | "custom"
;


Function:
    ret_type=ReturnType name=ID '(' params*=FunctionParameter[','] ')'
;

FunctionParameter:
    type=DataType name=ID ('='default=DefaultValue)?
;

DefaultValue:
    'none' | STRING | FLOAT | INT | BOOL
;

ReturnType:
    'void' | DataType
;

DataType:
    Number | Collection | Date | CustomType
;

CustomType:
    type=[TypeDef]
;

Date:
    'date'
;

Number:
    Integer | Float
;

Integer:
    'i16' | 'i32' | 'i64' | 'bool' | 'int'
;

Float:
    'float' | 'double'
;

Collection:
    Sequence | Set | Dict
;

Sequence:
    String | List
;

String:
    'str'
;

List:
    TypedList | NonTypedList
;

TypedList:
    'list' '<' type=DataType '>' ('[' len=INT ']')?
;

NonTypedList:
    'list'
;

Set:
    TypedSet | NonTypedSet
;

TypedSet:
    'set' '<' type=DataType '>'
;

NonTypedSet:
    'set'
;

Dict:
    TypedDict | NonTypedDict
;

TypedDict:
    'dict' '<' key_type=DataType ',' value_type=DataType '>'
;

NonTypedDict:
    'dict'
;

// Special rule for comments. Comments start with //
Comment:
    /\/\/.*$/
;